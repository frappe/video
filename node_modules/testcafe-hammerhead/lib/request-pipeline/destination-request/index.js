'use strict';

exports.__esModule = true;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require('babel-runtime/helpers/classCallCheck');

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _possibleConstructorReturn2 = require('babel-runtime/helpers/possibleConstructorReturn');

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require('babel-runtime/helpers/inherits');

var _inherits3 = _interopRequireDefault(_inherits2);

var _http = require('http');

var _http2 = _interopRequireDefault(_http);

var _https = require('https');

var _https2 = _interopRequireDefault(_https);

var _lodash = require('lodash');

var _agent = require('./agent');

var requestAgent = _interopRequireWildcard(_agent);

var _events = require('events');

var _webauth = require('webauth');

var _connectionResetGuard = require('../connection-reset-guard');

var _connectionResetGuard2 = _interopRequireDefault(_connectionResetGuard);

var _messages = require('../../messages');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// HACK: Ignore SSL auth. The rejectUnauthorized option in the https.request method
// doesn't work (see: https://github.com/mikeal/request/issues/418).
process.env.NODE_TLS_REJECT_UNAUTHORIZED = '0';

var TUNNELING_SOCKET_ERR_RE = /tunneling socket could not be established/i;
var TUNNELING_AUTHORIZE_ERR_RE = /statusCode=407/i;

// DestinationRequest

var DestinationRequest = function (_EventEmitter) {
    (0, _inherits3.default)(DestinationRequest, _EventEmitter);

    function DestinationRequest(opts) {
        (0, _classCallCheck3.default)(this, DestinationRequest);

        var _this = (0, _possibleConstructorReturn3.default)(this, _EventEmitter.call(this));

        _this.req = null;
        _this.hasResponse = false;
        _this.credentialsSent = false;
        _this.aborted = false;
        _this.opts = opts;
        _this.isHttps = opts.protocol === 'https:';
        _this.protocolInterface = _this.isHttps ? _https2.default : _http2.default;

        // NOTE: Ignore SSL auth.
        if (_this.isHttps) opts.rejectUnauthorized = false;

        requestAgent.assign(_this.opts);
        _this._send();
        return _this;
    }

    DestinationRequest.prototype._send = function _send(waitForData) {
        var _this2 = this;

        (0, _connectionResetGuard2.default)(function () {
            var timeout = _this2.opts.isXhr ? DestinationRequest.XHR_TIMEOUT : DestinationRequest.TIMEOUT;

            _this2.req = _this2.protocolInterface.request(_this2.opts, function (res) {
                if (waitForData) {
                    res.on('data', _lodash.noop);
                    res.once('end', function () {
                        return _this2._onResponse(res);
                    });
                }
            });

            if (!waitForData) _this2.req.on('response', function (res) {
                return _this2._onResponse(res);
            });

            _this2.req.on('error', function (err) {
                return _this2._onError(err);
            });
            _this2.req.setTimeout(timeout, function () {
                return _this2._onTimeout();
            });
            _this2.req.write(_this2.opts.body);
            _this2.req.end();
        });
    };

    DestinationRequest.prototype._shouldResendWithCredentials = function _shouldResendWithCredentials(res) {
        if (res.statusCode === 401 && this.opts.credentials) {
            var authInfo = (0, _webauth.getAuthInfo)(res);

            // NOTE: If we get 401 status code after credentials are sent, we should stop trying to authenticate.
            if (!authInfo.isChallengeMessage && this.credentialsSent) return false;

            return authInfo.canAuthorize;
        }

        return false;
    };

    DestinationRequest.prototype._onResponse = function _onResponse(res) {
        if (this._shouldResendWithCredentials(res)) this._resendWithCredentials(res);else if (!this.isHttps && this.opts.proxy && res.statusCode === 407) this._fatalError(_messages.MESSAGE.cantAuthorizeToProxy, this.opts.proxy.host);else {
            this.hasResponse = true;
            this.emit('response', res);
        }
    };

    DestinationRequest.prototype._resendWithCredentials = function () {
        var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(res) {
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            (0, _webauth.addCredentials)(this.opts.credentials, this.opts, res, this.protocolInterface);
                            this.credentialsSent = true;

                            // NOTE: NTLM authentication requires using the same socket for the "negotiate" and "authenticate" requests.
                            // So, before sending the "authenticate" message, we should wait for data from the "challenge" response. It
                            // will mean that the socket is free.
                            this._send((0, _webauth.requiresResBody)(res));

                        case 3:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, this);
        }));

        function _resendWithCredentials(_x) {
            return _ref.apply(this, arguments);
        }

        return _resendWithCredentials;
    }();

    DestinationRequest.prototype._fatalError = function _fatalError(msg, url) {
        if (!this.aborted) {
            this.aborted = true;
            this.req.abort();
            this.emit('fatalError', (0, _messages.getText)(msg, url || this.opts.url));
        }
    };

    DestinationRequest.prototype._isDNSErr = function _isDNSErr(err) {
        return err.message && /ECONNREFUSED|ENOTFOUND/.test(err.message) || !this.aborted && !this.hasResponse && err.code && /ECONNRESET/.test(err.code);
    };

    DestinationRequest.prototype._isTunnelingErr = function _isTunnelingErr(err) {
        return this.isHttps && this.opts.proxy && err.message && TUNNELING_SOCKET_ERR_RE.test(err.message);
    };

    DestinationRequest.prototype._onTimeout = function _onTimeout() {
        // NOTE: this handler is also called if we get an error response (for example, 404). So, we should check
        // for the response presence before raising the timeout error.
        if (!this.hasResponse) this._fatalError(_messages.MESSAGE.destRequestTimeout);
    };

    DestinationRequest.prototype._onError = function _onError(err) {
        if (requestAgent.shouldRegressHttps(err, this.opts)) {
            requestAgent.regressHttps(this.opts);
            this._send();
        } else if (this._isTunnelingErr(err)) {
            if (TUNNELING_AUTHORIZE_ERR_RE.test(err.message)) this._fatalError(_messages.MESSAGE.cantAuthorizeToProxy, this.opts.proxy.host);else this._fatalError(_messages.MESSAGE.cantEstablishTunnelingConnection, this.opts.proxy.host);
        } else if (this._isDNSErr(err)) {
            if (!this.isHttps && this.opts.proxy) this._fatalError(_messages.MESSAGE.cantEstablishProxyConnection, this.opts.proxy.host);else this._fatalError(_messages.MESSAGE.cantResolveUrl);
        } else this.emit('error');
    };

    return DestinationRequest;
}(_events.EventEmitter);

// NOTE: Exposed for testing purposes.


exports.default = DestinationRequest;
DestinationRequest.TIMEOUT = 25 * 1000;
DestinationRequest.XHR_TIMEOUT = 2 * 60 * 1000;
module.exports = exports['default'];
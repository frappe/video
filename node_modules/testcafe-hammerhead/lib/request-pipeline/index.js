'use strict';

exports.__esModule = true;

var _regenerator = require('babel-runtime/regenerator');

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require('babel-runtime/helpers/asyncToGenerator');

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

exports.run = run;

var _destinationRequest = require('./destination-request');

var _destinationRequest2 = _interopRequireDefault(_destinationRequest);

var _fileRequest = require('./file-request');

var _fileRequest2 = _interopRequireDefault(_fileRequest);

var _context4 = require('./context');

var _context5 = _interopRequireDefault(_context4);

var _headerTransforms = require('./header-transforms');

var headerTransforms = _interopRequireWildcard(_headerTransforms);

var _resources = require('../processing/resources');

var _messages = require('../messages');

var _connectionResetGuard = require('./connection-reset-guard');

var _connectionResetGuard2 = _interopRequireDefault(_connectionResetGuard);

var _sameOriginPolicy = require('./xhr/same-origin-policy');

var _http = require('../utils/http');

var _upload = require('../upload');

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// Stages
var stages = {
    0: function () {
        var _ref = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee(ctx, next) {
            return _regenerator2.default.wrap(function _callee$(_context) {
                while (1) {
                    switch (_context.prev = _context.next) {
                        case 0:
                            if (ctx.isPage && !ctx.isIframe) ctx.session.onPageRequest();

                            _context.next = 3;
                            return (0, _http.fetchBody)(ctx.req);

                        case 3:
                            ctx.reqBody = _context.sent;


                            next();

                        case 5:
                        case 'end':
                            return _context.stop();
                    }
                }
            }, _callee, this);
        }));

        function fetchProxyRequestBody(_x, _x2) {
            return _ref.apply(this, arguments);
        }

        return fetchProxyRequestBody;
    }(),

    1: function sendDestinationRequest(ctx, next) {
        var opts = createReqOpts(ctx);

        if (ctx.isSpecialPage) {
            mockDestinationResponseForSpecialPage(ctx);
            next();
        } else {
            var req = ctx.isFileProtocol ? new _fileRequest2.default(opts) : new _destinationRequest2.default(opts);

            req.on('response', function (res) {
                ctx.destRes = res;
                next();
            });

            req.on('error', function () {
                ctx.hasDestReqErr = true;
            });

            req.on('fatalError', function (err) {
                return error(ctx, err);
            });
        }
    },

    2: function checkSameOriginPolicyCompliance(ctx, next) {
        ctx.buildContentInfo();

        if ((ctx.isXhr || ctx.isFetch) && !ctx.contentInfo.isNotModified && !(0, _sameOriginPolicy.check)(ctx)) {
            ctx.closeWithError(_sameOriginPolicy.SAME_ORIGIN_CHECK_FAILED_STATUS_CODE);
            return;
        }

        next();
    },

    3: function decideOnProcessingStrategy(ctx, next) {
        if (ctx.contentInfo.requireProcessing && ctx.destRes.statusCode === 204) ctx.destRes.statusCode = 200;

        // NOTE: Just pipe the content body to the browser if we don't need to process it.
        if (!ctx.contentInfo.requireProcessing) {
            sendResponseHeaders(ctx);

            if (ctx.isSpecialPage) ctx.res.end('');else ctx.destRes.pipe(ctx.res);

            return;
        }

        next();
    },

    4: function () {
        var _ref2 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee2(ctx, next) {
            return _regenerator2.default.wrap(function _callee2$(_context2) {
                while (1) {
                    switch (_context2.prev = _context2.next) {
                        case 0:
                            if (!ctx.isSpecialPage) {
                                _context2.next = 4;
                                break;
                            }

                            ctx.destResBody = new Buffer(0);
                            _context2.next = 7;
                            break;

                        case 4:
                            _context2.next = 6;
                            return (0, _http.fetchBody)(ctx.destRes);

                        case 6:
                            ctx.destResBody = _context2.sent;

                        case 7:
                            if (!(ctx.hasDestReqErr && isDestResBodyMalformed(ctx))) {
                                _context2.next = 10;
                                break;
                            }

                            error(ctx, (0, _messages.getText)(_messages.MESSAGE.destConnectionTerminated, ctx.dest.url));

                            return _context2.abrupt('return');

                        case 10:

                            next();

                        case 11:
                        case 'end':
                            return _context2.stop();
                    }
                }
            }, _callee2, this);
        }));

        function fetchContent(_x3, _x4) {
            return _ref2.apply(this, arguments);
        }

        return fetchContent;
    }(),

    5: function () {
        var _ref3 = (0, _asyncToGenerator3.default)(_regenerator2.default.mark(function _callee3(ctx, next) {
            return _regenerator2.default.wrap(function _callee3$(_context3) {
                while (1) {
                    switch (_context3.prev = _context3.next) {
                        case 0:
                            _context3.prev = 0;
                            _context3.next = 3;
                            return (0, _resources.process)(ctx);

                        case 3:
                            ctx.destResBody = _context3.sent;

                            next();
                            _context3.next = 10;
                            break;

                        case 7:
                            _context3.prev = 7;
                            _context3.t0 = _context3['catch'](0);

                            error(ctx, _context3.t0);

                        case 10:
                        case 'end':
                            return _context3.stop();
                    }
                }
            }, _callee3, this, [[0, 7]]);
        }));

        function processContent(_x5, _x6) {
            return _ref3.apply(this, arguments);
        }

        return processContent;
    }(),

    6: function sendProxyResponse(ctx) {
        sendResponseHeaders(ctx);

        (0, _connectionResetGuard2.default)(function () {
            ctx.res.write(ctx.destResBody);
            ctx.res.end();
        });
    }
};

// Utils
function createReqOpts(ctx) {
    var bodyWithUploads = (0, _upload.inject)(ctx.req.headers['content-type'], ctx.reqBody);

    // NOTE: First, we should rewrite the request body, because the 'content-length' header will be built based on it.
    if (bodyWithUploads) ctx.reqBody = bodyWithUploads;

    // NOTE: All headers, including 'content-length', are built here.
    var headers = headerTransforms.forRequest(ctx);
    var proxy = ctx.session.externalProxySettings;
    var options = {
        url: ctx.dest.url,
        protocol: ctx.dest.protocol,
        hostname: ctx.dest.hostname,
        host: ctx.dest.host,
        port: ctx.dest.port,
        path: ctx.dest.partAfterHost,
        method: ctx.req.method,
        credentials: ctx.session.getAuthCredentials(),
        body: ctx.reqBody,
        isXhr: ctx.isXhr,

        proxy: proxy,
        headers: headers
    };

    if (proxy && ctx.dest.protocol === 'http:') {
        options.path = options.protocol + '//' + options.host + options.path;
        options.host = proxy.host;
        options.hostname = proxy.hostname;
        options.port = proxy.port;

        if (proxy.authHeader) headers['proxy-authorization'] = proxy.authHeader;
    }

    return options;
}

function sendResponseHeaders(ctx) {
    var headers = headerTransforms.forResponse(ctx);

    ctx.res.writeHead(ctx.destRes.statusCode, headers);
    ctx.res.addTrailers(ctx.destRes.trailers);
}

function error(ctx, err) {
    if (ctx.isPage && !ctx.isIframe) ctx.session.handlePageError(ctx, err);else ctx.closeWithError(500, err);
}

function isDestResBodyMalformed(ctx) {
    return !ctx.destResBody || ctx.destResBody.length !== ctx.destRes.headers['content-length'];
}

function mockDestinationResponseForSpecialPage(ctx) {
    ctx.destRes = {
        headers: {
            'content-type': 'text/html',
            'content-length': '0'
        },

        statusCode: 200,
        trailers: {}
    };
}

// API
function run(req, res, serverInfo, openSessions) {
    var ctx = new _context5.default(req, res, serverInfo);

    if (ctx.dispatch(openSessions)) {
        var stageIdx = 0;
        var next = function next() {
            return stages[++stageIdx](ctx, next);
        };

        stages[0](ctx, next);
    } else (0, _http.respond404)(res);
}
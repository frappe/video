// This file was generated by modules-webmake (modules for web) project.
// See: https://github.com/medikoo/modules-webmake

(function (modules) {
	'use strict';

	var resolve, getRequire, wmRequire, notFoundError, findFile
	  , extensions = {".js":[],".json":[],".css":[],".html":[]}
	  , envRequire = typeof require === 'function' ? require : null;

	notFoundError = function (path) {
		var error = new Error("Could not find module '" + path + "'");
		error.code = 'MODULE_NOT_FOUND';
		return error;
	};
	findFile = function (scope, name, extName) {
		var i, ext;
		if (typeof scope[name + extName] === 'function') return name + extName;
		for (i = 0; (ext = extensions[extName][i]); ++i) {
			if (typeof scope[name + ext] === 'function') return name + ext;
		}
		return null;
	};
	resolve = function (scope, tree, path, fullPath, state, id) {
		var name, dir, exports, module, fn, found, ext;
		path = path.split(/[\\/]/);
		name = path.pop();
		if ((name === '.') || (name === '..')) {
			path.push(name);
			name = '';
		}
		while ((dir = path.shift()) != null) {
			if (!dir || (dir === '.')) continue;
			if (dir === '..') {
				scope = tree.pop();
				id = id.slice(0, id.lastIndexOf('/'));
			} else {
				tree.push(scope);
				scope = scope[dir];
				id += '/' + dir;
			}
			if (!scope) throw notFoundError(fullPath);
		}
		if (name && (typeof scope[name] !== 'function')) {
			found = findFile(scope, name, '.js');
			if (!found) found = findFile(scope, name, '.json');
			if (!found) found = findFile(scope, name, '.css');
			if (!found) found = findFile(scope, name, '.html');
			if (found) {
				name = found;
			} else if ((state !== 2) && (typeof scope[name] === 'object')) {
				tree.push(scope);
				scope = scope[name];
				id += '/' + name;
				name = '';
			}
		}
		if (!name) {
			if ((state !== 1) && scope[':mainpath:']) {
				return resolve(scope, tree, scope[':mainpath:'], fullPath, 1, id);
			}
			return resolve(scope, tree, 'index', fullPath, 2, id);
		}
		fn = scope[name];
		if (!fn) throw notFoundError(fullPath);
		if (fn.hasOwnProperty('module')) return fn.module.exports;
		exports = {};
		fn.module = module = { exports: exports, id: id + '/' + name };
		fn.call(exports, exports, module, getRequire(scope, tree, id));
		return module.exports;
	};
	wmRequire = function (scope, tree, fullPath, id) {
		var name, path = fullPath, t = fullPath.charAt(0), state = 0;
		if (t === '/') {
			path = path.slice(1);
			scope = modules['/'];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = '/';
			tree = [];
		} else if (t !== '.') {
			name = path.split('/', 1)[0];
			scope = modules[name];
			if (!scope) {
				if (envRequire) return envRequire(fullPath);
				throw notFoundError(fullPath);
			}
			id = name;
			tree = [];
			path = path.slice(name.length + 1);
			if (!path) {
				path = scope[':mainpath:'];
				if (path) {
					state = 1;
				} else {
					path = 'index';
					state = 2;
				}
			}
		}
		return resolve(scope, tree, path, fullPath, state, id);
	};
	getRequire = function (scope, tree, id) {
		return function (path) {
			return wmRequire(scope, [].concat(tree), path, id);
		};
	};
	return getRequire(modules, [], '');
})({
	"pinkie": {
		"index.js": function (exports, module, require) {
			

			var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

			var PENDING = 'pending';
			var SETTLED = 'settled';
			var FULFILLED = 'fulfilled';
			var REJECTED = 'rejected';
			var NOOP = function NOOP() {};
			var isNode = typeof global !== 'undefined' && typeof global.process !== 'undefined' && typeof global.process.emit === 'function';

			var asyncSetTimer = typeof setImmediate === 'undefined' ? setTimeout : setImmediate;
			var asyncQueue = [];
			var asyncTimer;

			function asyncFlush() {
				// run promise callbacks
				for (var i = 0; i < asyncQueue.length; i++) {
					asyncQueue[i][0](asyncQueue[i][1]);
				}

				// reset async asyncQueue
				asyncQueue = [];
				asyncTimer = false;
			}

			function asyncCall(callback, arg) {
				asyncQueue.push([callback, arg]);

				if (!asyncTimer) {
					asyncTimer = true;
					asyncSetTimer(asyncFlush, 0);
				}
			}

			function invokeResolver(resolver, promise) {
				function resolvePromise(value) {
					resolve(promise, value);
				}

				function rejectPromise(reason) {
					reject(promise, reason);
				}

				try {
					resolver(resolvePromise, rejectPromise);
				} catch (e) {
					rejectPromise(e);
				}
			}

			function invokeCallback(subscriber) {
				var owner = subscriber.owner;
				var settled = owner._state;
				var value = owner._data;
				var callback = subscriber[settled];
				var promise = subscriber.then;

				if (typeof callback === 'function') {
					settled = FULFILLED;
					try {
						value = callback(value);
					} catch (e) {
						reject(promise, e);
					}
				}

				if (!handleThenable(promise, value)) {
					if (settled === FULFILLED) {
						resolve(promise, value);
					}

					if (settled === REJECTED) {
						reject(promise, value);
					}
				}
			}

			function handleThenable(promise, value) {
				var resolved;

				try {
					if (promise === value) {
						throw new TypeError('A promises callback cannot return that same promise.');
					}

					if (value && (typeof value === 'function' || (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object')) {
						// then should be retrieved only once
						var then = value.then;

						if (typeof then === 'function') {
							then.call(value, function (val) {
								if (!resolved) {
									resolved = true;

									if (value === val) {
										fulfill(promise, val);
									} else {
										resolve(promise, val);
									}
								}
							}, function (reason) {
								if (!resolved) {
									resolved = true;

									reject(promise, reason);
								}
							});

							return true;
						}
					}
				} catch (e) {
					if (!resolved) {
						reject(promise, e);
					}

					return true;
				}

				return false;
			}

			function resolve(promise, value) {
				if (promise === value || !handleThenable(promise, value)) {
					fulfill(promise, value);
				}
			}

			function fulfill(promise, value) {
				if (promise._state === PENDING) {
					promise._state = SETTLED;
					promise._data = value;

					asyncCall(publishFulfillment, promise);
				}
			}

			function reject(promise, reason) {
				if (promise._state === PENDING) {
					promise._state = SETTLED;
					promise._data = reason;

					asyncCall(publishRejection, promise);
				}
			}

			function publish(promise) {
				promise._then = promise._then.forEach(invokeCallback);
			}

			function publishFulfillment(promise) {
				promise._state = FULFILLED;
				publish(promise);
			}

			function publishRejection(promise) {
				promise._state = REJECTED;
				publish(promise);
				if (!promise._handled && isNode) {
					global.process.emit('unhandledRejection', promise._data, promise);
				}
			}

			function notifyRejectionHandled(promise) {
				global.process.emit('rejectionHandled', promise);
			}

			/**
			 * @class
			 */
			function Promise(resolver) {
				if (typeof resolver !== 'function') {
					throw new TypeError('Promise resolver ' + resolver + ' is not a function');
				}

				if (this instanceof Promise === false) {
					throw new TypeError('Failed to construct \'Promise\': Please use the \'new\' operator, this object constructor cannot be called as a function.');
				}

				this._then = [];

				invokeResolver(resolver, this);
			}

			Promise.prototype = {
				constructor: Promise,

				_state: PENDING,
				_then: null,
				_data: undefined,
				_handled: false,

				then: function then(onFulfillment, onRejection) {
					var subscriber = {
						owner: this,
						then: new this.constructor(NOOP),
						fulfilled: onFulfillment,
						rejected: onRejection
					};

					if ((onRejection || onFulfillment) && !this._handled) {
						this._handled = true;
						if (this._state === REJECTED && isNode) {
							asyncCall(notifyRejectionHandled, this);
						}
					}

					if (this._state === FULFILLED || this._state === REJECTED) {
						// already resolved, call callback async
						asyncCall(invokeCallback, subscriber);
					} else {
						// subscribe
						this._then.push(subscriber);
					}

					return subscriber.then;
				},

				catch: function _catch(onRejection) {
					return this.then(null, onRejection);
				}
			};

			Promise.all = function (promises) {
				if (!Array.isArray(promises)) {
					throw new TypeError('You must pass an array to Promise.all().');
				}

				return new Promise(function (resolve, reject) {
					var results = [];
					var remaining = 0;

					function resolver(index) {
						remaining++;
						return function (value) {
							results[index] = value;
							if (! --remaining) {
								resolve(results);
							}
						};
					}

					for (var i = 0, promise; i < promises.length; i++) {
						promise = promises[i];

						if (promise && typeof promise.then === 'function') {
							promise.then(resolver(i), reject);
						} else {
							results[i] = promise;
						}
					}

					if (!remaining) {
						resolve(results);
					}
				});
			};

			Promise.race = function (promises) {
				if (!Array.isArray(promises)) {
					throw new TypeError('You must pass an array to Promise.race().');
				}

				return new Promise(function (resolve, reject) {
					for (var i = 0, promise; i < promises.length; i++) {
						promise = promises[i];

						if (promise && typeof promise.then === 'function') {
							promise.then(resolve, reject);
						} else {
							resolve(promise);
						}
					}
				});
			};

			Promise.resolve = function (value) {
				if (value && (typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object' && value.constructor === Promise) {
					return value;
				}

				return new Promise(function (resolve) {
					resolve(value);
				});
			};

			Promise.reject = function (reason) {
				return new Promise(function (resolve, reject) {
					reject(reason);
				});
			};

			module.exports = Promise;
		}
	},
	"testcafe-phoenix": {
		"src": {
			"browser": {
				"connection": {
					"command.js": function (exports, module, require) {
						

						exports.__esModule = true;
						// --------------------------------------------------------
						// WARNING: this file is used by both the client and the server.
						// Do not use any browser or node-specific API!
						// --------------------------------------------------------

						exports.default = {
						    run: 'run',
						    idle: 'idle'
						};
						module.exports = exports['default'];
					}
				}
			},
			"client": {
				"browser": {
					"idle-page": {
						"index.js": function (exports, module, require) {
							

							var _ = require('../');

							var browser = _interopRequireWildcard(_);

							var _statusIndicator = require('./status-indicator');

							var _statusIndicator2 = _interopRequireDefault(_statusIndicator);

							var _command = require('../../../browser/connection/command');

							var _command2 = _interopRequireDefault(_command);

							function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

							function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							var CHECK_STATUS_DELAY = 1000;

							var createXHR = function createXHR() {
							    return new XMLHttpRequest();
							};

							var IdlePage = function () {
							    function IdlePage(statusUrl, heartbeatUrl, initScriptUrl) {
							        _classCallCheck(this, IdlePage);

							        this.statusUrl = statusUrl;
							        this.statusIndicator = new _statusIndicator2.default();

							        browser.startHeartbeat(heartbeatUrl, createXHR);
							        browser.startInitScriptExecution(initScriptUrl, createXHR);

							        this._checkStatus();

							        document.title = '[' + document.location.toString() + ']';
							    }

							    IdlePage.prototype._checkStatus = function _checkStatus() {
							        var _this = this;

							        browser.checkStatus(this.statusUrl, createXHR).then(function (cmd) {
							            if (cmd === _command2.default.idle) window.setTimeout(function () {
							                return _this._checkStatus();
							            }, CHECK_STATUS_DELAY);
							        }).catch(function () {
							            return _this.statusIndicator.showDisconnection();
							        });
							    };

							    return IdlePage;
							}();

							window.IdlePage = IdlePage;
						},
						"status-indicator.js": function (exports, module, require) {
							

							exports.__esModule = true;

							function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

							var SPINNER_WIDTH = 8;
							var RELATED_SPINNER_SIZE = 0.8;
							var MAXIMUM_SPINNER_SIZE = 400;
							var ROTATION_ANGLE = 7;
							var FONT_SIZE_EQUATION_SLOPE = 0.03;
							var FONT_SIZE_EQUATION_Y_INTERCEPT = 3.5;
							var START_GRADIENT_POINT_OFFSET = { x: 0.75, y: 0.7 };
							var END_GRADIENT_POINT_OFFSET = { x: 1.025, y: 0.575 };

							var LINE_HEIGHT_INDENT = 6;

							var CONNECTED_SPINNER_COLOR = '#28687F';
							var DISCONNECTED_SPINNER_COLOR = '#882E24';
							var SPINNER_GRADIENT_COLOR = '#181818';

							var CONNECTED_TEXT = 'CONNECTED';
							var DISCONNECTED_TEXT = 'DISCONNECTED';

							var PAGE_BACKGROUND_CLASS_NAME = 'page-background';
							var CONTAINER_CLASS_NAME = 'container';
							var USER_AGENT_ELEMENT_CLASS_NAME = 'user-agent';
							var STATUS_ELEMENT_CLASS_NAME = 'status';
							var CANVAS_CLASS_NAME = 'spinner';

							var CONNECTED_CLASS_NAME = 'connected';
							var DISCONNECTED_CLASS_NAME = 'disconnected';

							var ANIMATION_DELAY = 30;

							//Utils
							function convertToRadian(angle) {
							    return angle * Math.PI / 180;
							}

							function convertToString(value) {
							    return value + 'px';
							}

							function rotateAxes(point, rotationAngle) {
							    var angle = convertToRadian(rotationAngle);

							    return {
							        x: Math.round(point.x * Math.cos(angle) - point.y * Math.sin(angle)),
							        y: Math.round(point.x * Math.sin(angle) + point.y * Math.cos(angle))
							    };
							}

							function moveAxes(point, distance) {
							    return {
							        x: Math.round(point.x - distance),
							        y: Math.round(point.y - distance)
							    };
							}

							var StatusIndicator = function () {
							    function StatusIndicator() {
							        _classCallCheck(this, StatusIndicator);

							        this.connected = true;
							        this.canvas = document.getElementsByClassName(CANVAS_CLASS_NAME)[0];
							        this.canvasContext = this.canvas.getContext('2d');

							        this.spinnerAnimationInterval = null;
							        this.rotationAngle = 0;
							        this.size = null;
							        this.spinnerCenter = null;
							        this.gradient = null;

							        this._setSize();
							        this._setFontSize();
							        this._setSpinnerGradient();

							        StatusIndicator._createStatusMessage(this.connected);
							        StatusIndicator._alignContainerVertically();

							        this._drawSpinner(this.connected, 0);
							        this._watchWindowResize();
							    }

							    //Markup


							    StatusIndicator._getContainer = function _getContainer() {
							        return document.getElementsByClassName(CONTAINER_CLASS_NAME)[0];
							    };

							    StatusIndicator._getStatusElementSpan = function _getStatusElementSpan() {
							        return document.getElementsByClassName(STATUS_ELEMENT_CLASS_NAME)[0].children[0];
							    };

							    StatusIndicator._createStatusMessage = function _createStatusMessage(connected) {
							        var statusSpan = StatusIndicator._getStatusElementSpan();

							        statusSpan.className = connected ? CONNECTED_CLASS_NAME : DISCONNECTED_CLASS_NAME;
							        statusSpan.textContent = connected ? CONNECTED_TEXT : DISCONNECTED_TEXT;
							    };

							    StatusIndicator._alignContainerVertically = function _alignContainerVertically() {
							        var background = document.getElementsByClassName(PAGE_BACKGROUND_CLASS_NAME)[0];
							        var container = StatusIndicator._getContainer();

							        var topMargin = Math.ceil((background.offsetHeight - container.offsetHeight) / 2);

							        if (topMargin > 0) container.style.marginTop = convertToString(topMargin);
							    };

							    StatusIndicator.prototype._setSize = function _setSize() {
							        var documentElement = window.document.documentElement;
							        var minResolution = Math.min(documentElement.clientWidth, documentElement.clientHeight);
							        var container = StatusIndicator._getContainer();
							        var newSize = Math.round(Math.min(MAXIMUM_SPINNER_SIZE, minResolution * RELATED_SPINNER_SIZE));

							        if (newSize === this.size) return;

							        this.size = Math.round(Math.min(MAXIMUM_SPINNER_SIZE, minResolution * RELATED_SPINNER_SIZE));
							        this.spinnerCenter = this.size / 2;

							        container.style.width = convertToString(this.size);
							        container.style.height = convertToString(this.size);

							        this.canvas.width = this.canvas.height = this.size;
							    };

							    StatusIndicator.prototype._setFontSize = function _setFontSize() {
							        var userAgentSpan = document.getElementsByClassName(USER_AGENT_ELEMENT_CLASS_NAME)[0].children[0];
							        var statusSpan = StatusIndicator._getStatusElementSpan();

							        // NOTE: We have established proportions for two edge cases:
							        // the maximum spinner size of 400px corresponds to the 16px font,
							        // the minimum spinner size of 240px corresponds to the 11px font.
							        // Actual sizes are calculated from these proportions.
							        var fontSize = Math.round(FONT_SIZE_EQUATION_SLOPE * this.size + FONT_SIZE_EQUATION_Y_INTERCEPT);
							        var lineHeight = fontSize + LINE_HEIGHT_INDENT;

							        userAgentSpan.style.fontSize = convertToString(fontSize);
							        userAgentSpan.style.lineHeight = convertToString(lineHeight);
							        userAgentSpan.style.maxHeight = convertToString(2 * lineHeight);

							        statusSpan.style.fontSize = convertToString(fontSize);
							        statusSpan.style.lineHeight = convertToString(lineHeight - 1);
							    };

							    StatusIndicator.prototype._watchWindowResize = function _watchWindowResize() {
							        var _this = this;

							        window.onresize = function () {
							            var oldSize = _this.size;

							            _this._setSize();
							            _this._setFontSize();

							            StatusIndicator._alignContainerVertically();

							            if (oldSize !== _this.size) {
							                if (_this.connected) _this._setSpinnerGradient();

							                _this._drawSpinner(_this.connected, _this.rotationAngle);
							            }
							        };
							    };

							    //Spinner


							    StatusIndicator.prototype._drawSpinner = function _drawSpinner(connected, startAngle) {
							        var _this2 = this;

							        this._clearCanvas();
							        clearInterval(this.spinnerAnimationInterval);

							        if (connected) {
							            this.spinnerAnimationInterval = window.setInterval(function () {
							                _this2._clearCanvas();
							                _this2._rotateSpinner();
							                _this2._drawCircle(_this2.gradient, 240, startAngle);
							            }, ANIMATION_DELAY);

							            this._drawCircle(this.gradient, 240, startAngle);
							        } else this._drawCircle(DISCONNECTED_SPINNER_COLOR, 360, 0);
							    };

							    StatusIndicator.prototype._drawCircle = function _drawCircle(strokeStyle, centralAngle, startAngle) {
							        var radius = this.spinnerCenter - SPINNER_WIDTH / 2;

							        this.canvasContext.beginPath();

							        this.canvasContext.lineWidth = SPINNER_WIDTH;
							        this.canvasContext.strokeStyle = strokeStyle;

							        this.canvasContext.arc(this.spinnerCenter, this.spinnerCenter, radius, convertToRadian(startAngle), convertToRadian(startAngle + centralAngle), false);

							        this.canvasContext.stroke();
							    };

							    StatusIndicator.prototype._rotateSpinner = function _rotateSpinner() {
							        this.rotationAngle += ROTATION_ANGLE;

							        this.rotationAngle = this.rotationAngle > 360 ? this.rotationAngle % 360 : this.rotationAngle;

							        this.canvasContext.translate(this.spinnerCenter, this.spinnerCenter);
							        this.canvasContext.rotate(convertToRadian(ROTATION_ANGLE));
							        this.canvasContext.translate(-this.spinnerCenter, -this.spinnerCenter);
							    };

							    StatusIndicator.prototype._getRotatedGradientPoints = function _getRotatedGradientPoints(point) {
							        var changedPoint = moveAxes(point, this.spinnerCenter);

							        changedPoint = rotateAxes(changedPoint, this.rotationAngle);
							        changedPoint = moveAxes(changedPoint, -this.spinnerCenter);

							        return changedPoint;
							    };

							    StatusIndicator.prototype._setSpinnerGradient = function _setSpinnerGradient() {
							        var startGradientPoint = {
							            x: Math.round(this.size * START_GRADIENT_POINT_OFFSET.x),
							            y: Math.round(this.size * START_GRADIENT_POINT_OFFSET.y)
							        };

							        var endGradientPoint = {
							            x: Math.round(this.size * END_GRADIENT_POINT_OFFSET.x),
							            y: Math.round(this.size * END_GRADIENT_POINT_OFFSET.y)
							        };

							        if (this.rotationAngle !== 0) {
							            startGradientPoint = this._getRotatedGradientPoints(startGradientPoint);
							            endGradientPoint = this._getRotatedGradientPoints(endGradientPoint);
							        }

							        var gradient = this.canvasContext.createLinearGradient(startGradientPoint.x, startGradientPoint.y, endGradientPoint.x, endGradientPoint.y);

							        gradient.addColorStop(0, CONNECTED_SPINNER_COLOR);
							        gradient.addColorStop(1, SPINNER_GRADIENT_COLOR);

							        this.gradient = gradient;
							    };

							    StatusIndicator.prototype._clearCanvas = function _clearCanvas() {
							        this.canvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
							    };

							    //API


							    StatusIndicator.prototype.showDisconnection = function showDisconnection() {
							        this.connected = false;
							        StatusIndicator._createStatusMessage(this.connected);
							        this._drawSpinner(this.connected, 0);
							    };

							    return StatusIndicator;
							}();

							exports.default = StatusIndicator;
							module.exports = exports['default'];
						}
					},
					"index.js": function (exports, module, require) {
						

						exports.__esModule = true;
						exports.startHeartbeat = startHeartbeat;
						exports.startInitScriptExecution = startInitScriptExecution;
						exports.stopInitScriptExecution = stopInitScriptExecution;
						exports.checkStatus = checkStatus;

						var _pinkie = require('pinkie');

						var _pinkie2 = _interopRequireDefault(_pinkie);

						var _command = require('../../browser/connection/command');

						var _command2 = _interopRequireDefault(_command);

						function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

						// TODO: once we'll have client commons load it from there instead of node modules (currently it's leads to two copies of this packages on client)
						var HEARTBEAT_INTERVAL = 30 * 1000;

						var allowInitScriptExecution = false;

						//Utils
						// NOTE: the window.XMLHttpRequest may have been wrapped by Hammerhead, while we should send a request to
						// the original URL. That's why we need the XMLHttpRequest argument to send the request via native methods.
						function sendXHR(url, createXHR) {
						    var method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'GET';
						    var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;

						    return new _pinkie2.default(function (resolve, reject) {
						        var xhr = createXHR();

						        xhr.open(method, url, true);

						        xhr.onreadystatechange = function () {
						            if (xhr.readyState === 4) {
						                if (xhr.status === 200) resolve(xhr.responseText ? JSON.parse(xhr.responseText) : '');else reject('disconnected');
						            }
						        };

						        xhr.send(data);
						    });
						}

						function isCurrentLocation(url) {
						    return document.location.href.toLowerCase() === url.toLowerCase();
						}

						//API
						function startHeartbeat(heartbeatUrl, createXHR) {
						    sendXHR(heartbeatUrl, createXHR);

						    window.setInterval(function () {
						        return sendXHR(heartbeatUrl, createXHR);
						    }, HEARTBEAT_INTERVAL);
						}

						function executeInitScript(initScriptUrl, createXHR) {
						    if (!allowInitScriptExecution) return;

						    sendXHR(initScriptUrl, createXHR).then(function (res) {
						        if (!res.code) return null;

						        /* eslint-disable no-eval */
						        return sendXHR(initScriptUrl, createXHR, 'POST', JSON.stringify(eval(res.code)));
						        /* eslint-enable no-eval */
						    }).then(function () {
						        window.setTimeout(function () {
						            return executeInitScript(initScriptUrl, createXHR);
						        }, 1000);
						    });
						}

						function startInitScriptExecution(initScriptUrl, createXHR) {
						    allowInitScriptExecution = true;

						    executeInitScript(initScriptUrl, createXHR);
						}

						function stopInitScriptExecution() {
						    allowInitScriptExecution = false;
						}

						function checkStatus(statusUrl, createXHR) {
						    return sendXHR(statusUrl, createXHR).then(function (res) {
						        if (res.cmd === _command2.default.run || res.cmd === _command2.default.idle && !isCurrentLocation(res.url)) {
						            stopInitScriptExecution();
						            document.location = res.url;
						        }

						        return res.cmd;
						    });
						}
					}
				}
			}
		}
	}
})("testcafe-phoenix/src/client/browser/idle-page/index");
